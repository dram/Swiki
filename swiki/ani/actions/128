"compensate for the limits of the *++* format	REQUIRED	src = the name of the image	OPTIONAL	alt = the ALT tag	page = the page where the file is found"| options src file filePage uploads pageUploads return versions |options _ request settingsAt: 'options'.return _ nil."Get src field and page field"(src _ options at: 'src' ifAbsent: [nil]) ifNil: [	return _ '<b>FILE function must have a <em>src</em> field.</b>'].filePage _ (filePage _ options at: 'page' ifAbsent: [nil])	ifNil: [page]	ifNotNil: [filePage isAllDigits		ifTrue: [book pages at: (filePage asInteger)			ifAbsent: [return _ '<b>FILE function <em>page</em> must be a valid page number.</b>']]		ifFalse: [return _ '<b>FILE function <em>page</em> field must be an integer.</b>']].return ifNil: [	"Find the file"	uploads _ book modulesAt: 'uploads'.	versions _ nil.	((filePage accessLevelForRequest: request) > 0) ifTrue: [		"Try to find the file in the page directory"		pageUploads _ uploads directoryNamed: filePage id asString.		versions _ pageUploads fileRefsCacheAt: src ifAbsent: [nil]].	versions		ifNil: ["Try to find the file in the book directory"			versions _ uploads fileRefsCacheAt: src ifAbsent: [				return _ '<b>FILE function cannot find the upload.</b>']]		ifNotNil: [uploads _ pageUploads]]."reference the file"return	ifNil: ["Reference the file without inlining"		file _ versions last.		String streamContents: [:stream | stream			nextPutAll: '<a class="internal" href="';			nextPutAll: (book settingsAt: 'uploadServerPath');			nextPutAll: uploads httpPath;			nextPutAll: file httpName;			nextPutAll: '" title="';			nextPutAll: versions strictXmlName;			nextPutAll: ': uploaded ';			nextPutAll: file modificationDateString;			nextPutAll: ' at ';			nextPutAll: file modificationTimeString;			nextPutAll: '">';			nextPutAll: (options at: 'alt' ifAbsent: [				versions strictXmlName]);			nextPutAll: '</a>']]	ifNotNil: [return]